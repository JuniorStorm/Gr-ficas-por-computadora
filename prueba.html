<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>Visualizar OBJ + Centroides - WebGL</title>
<style>
  body { margin:0; overflow:hidden; background:#111; color:white; font-family:monospace; }
  #info { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.5); padding:8px; border-radius:6px; }
  canvas { width:100vw; height:100vh; display:block; }
</style>
</head>
<body>
<div id="info">Visualizando <b>esfera.obj</b> + centroides ‚Äî abre la consola (F12)</div>
<canvas id="glcanvas"></canvas>

<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
<script>
"use strict";

const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl");
if (!gl) alert("WebGL no disponible.");

function resize(){
  canvas.width = innerWidth;
  canvas.height = innerHeight;
  gl.viewport(0,0,canvas.width,canvas.height);
}
window.addEventListener("resize",resize);
resize();

/* --- Shaders principales (modelo) --- */
const vsMain = `
attribute vec3 aPosition;
attribute vec3 aNormal;
uniform mat4 uMVP;
uniform mat3 uNormalMat;
varying vec3 vNormal;
void main(){
  gl_Position = uMVP * vec4(aPosition,1.0);
  vNormal = normalize(uNormalMat * aNormal);
}`;
const fsMain = `
precision mediump float;
varying vec3 vNormal;
uniform vec3 uLightDir;
void main(){
  float diff = max(dot(normalize(vNormal), normalize(uLightDir)), 0.0);
  vec3 color = vec3(0.2,0.7,1.0) * (0.3 + 0.7*diff);
  gl_FragColor = vec4(color,1.0);
}`;

/* --- Shaders para puntos (centroides) --- */
const vsPoints = `
attribute vec3 aPosition;
uniform mat4 uMVP;
void main(){
  gl_Position = uMVP * vec4(aPosition,1.0);
  gl_PointSize = 6.0;
}`;
const fsPoints = `
precision mediump float;
void main(){
  gl_FragColor = vec4(1.0,0.1,0.1,1.0);  // rojo brillante
}`;

/* --- Shaders para picos (l√≠neas) --- */
const vsLines = `
attribute vec3 aPosition;
uniform mat4 uMVP;
void main(){
  gl_Position = uMVP * vec4(aPosition,1.0);
}`;
const fsLines = `
precision mediump float;
void main(){
  gl_FragColor = vec4(1.0,1.0,0.0,1.0); // amarillo
}`;

/* --- Compilar y enlazar programas --- */
function createProgram(vsSrc, fsSrc){
  function compile(src, type){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
      console.error(gl.getShaderInfoLog(s));
    return s;
  }
  const prog = gl.createProgram();
  gl.attachShader(prog, compile(vsSrc, gl.VERTEX_SHADER));
  gl.attachShader(prog, compile(fsSrc, gl.FRAGMENT_SHADER));
  gl.linkProgram(prog);
  return prog;
}
const programMain = createProgram(vsMain, fsMain);
const programPoints = createProgram(vsPoints, fsPoints);
const programLines = createProgram(vsLines, fsLines);


/* --- Cargar archivo OBJ --- */
async function loadOBJ(url){
  const text = await fetch(url).then(r=>r.text());
  const pos=[], nor=[], faces=[];
  for(let line of text.split("\n")){
    const p = line.trim().split(/\s+/);
    if(p[0]==="v") pos.push([+p[1],+p[2],+p[3]]);
    else if(p[0]==="vn") nor.push([+p[1],+p[2],+p[3]]);
    else if(p[0]==="f"){
      const vs = p.slice(1).map(f=>{
        const [v,_,n]=f.split("/").map(x=>x?parseInt(x):null);
        return {v:v-1,n:n-1};
      });
      for(let i=1;i<vs.length-1;i++)
        faces.push([vs[0],vs[i],vs[i+1]]);
    }
  }

  console.log(`\nüîπ Total de tri√°ngulos: ${faces.length}`);

  console.log("--------------------------------------");

  const verts=[], norms=[], centroids=[], linePoints=[];
faces.forEach((f,i)=>{
  const a = pos[f[0].v];
  const b = pos[f[1].v];
  const c = pos[f[2].v];
  const nx = (nor[f[0].n][0] + nor[f[1].n][0] + nor[f[2].n][0]) / 3;
  const ny = (nor[f[0].n][1] + nor[f[1].n][1] + nor[f[2].n][1]) / 3;
  const nz = (nor[f[0].n][2] + nor[f[1].n][2] + nor[f[2].n][2]) / 3;
  const cx = (a[0]+b[0]+c[0])/3;
  const cy = (a[1]+b[1]+c[1])/3;
  const cz = (a[2]+b[2]+c[2])/3;
  centroids.push(cx,cy,cz);
      console.log(`Tri√°ngulo ${i}: centroide = (${cx.toFixed(5)}, ${cy.toFixed(5)}, ${cz.toFixed(5)})`);
      console.log("--------------------------------------");

  // Pico desde centroide
  const length = 0.1;
  linePoints.push(cx,cy,cz);
  linePoints.push(cx + nx*length, cy + ny*length, cz + nz*length);

  for(const v of f){
    const p = pos[v.v];
    const n = nor[v.n] || [0,0,1];
    verts.push(...p);
    norms.push(...n);
  }
});
return {
  verts: new Float32Array(verts),
  norms: new Float32Array(norms),
  centroids: new Float32Array(centroids),
  linePoints: new Float32Array(linePoints)
};

  return {
    verts: new Float32Array(verts),
    norms: new Float32Array(norms),
    centroids: new Float32Array(centroids)
  };
}

/* --- Main --- */
async function main(){
  const obj = await loadOBJ("esfera.obj");

  // Buffers para modelo
  const vboPos = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
  gl.bufferData(gl.ARRAY_BUFFER, obj.verts, gl.STATIC_DRAW);
  const vboNorm = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm);
  gl.bufferData(gl.ARRAY_BUFFER, obj.norms, gl.STATIC_DRAW);

  // Buffer para centroides
  const vboCentroides = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vboCentroides);
  gl.bufferData(gl.ARRAY_BUFFER, obj.centroids, gl.STATIC_DRAW);

  const vboLines = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vboLines);
gl.bufferData(gl.ARRAY_BUFFER, obj.linePoints, gl.STATIC_DRAW);

  gl.enable(gl.DEPTH_TEST);
  gl.clearColor(0.1, 0.1, 0.1, 1);

  function draw(t){
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    const aspect = canvas.width / canvas.height;
    const proj = m4.perspective(Math.PI/4, aspect, 0.1, 100);
    const view = m4.translation(0, 0, -5);
    const model = m4.yRotation(t * 0.001);
    const mvp = m4.multiply(proj, m4.multiply(view, model));
    const normalMat = [
      model[0],model[1],model[2],
      model[4],model[5],model[6],
      model[8],model[9],model[10]
    ];

    // --- Dibujar malla principal ---
    gl.useProgram(programMain);
    let aPos = gl.getAttribLocation(programMain, "aPosition");
    let aNorm = gl.getAttribLocation(programMain, "aNormal");
    let uMVP = gl.getUniformLocation(programMain, "uMVP");
    let uNormalMat = gl.getUniformLocation(programMain, "uNormalMat");
    let uLightDir = gl.getUniformLocation(programMain, "uLightDir");

    gl.bindBuffer(gl.ARRAY_BUFFER, vboPos);
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, vboNorm);
    gl.enableVertexAttribArray(aNorm);
    gl.vertexAttribPointer(aNorm, 3, gl.FLOAT, false, 0, 0);
    gl.uniformMatrix4fv(uMVP, false, mvp);
    gl.uniformMatrix3fv(uNormalMat, false, normalMat);
    gl.uniform3fv(uLightDir, [0.5, 0.7, 1.0]);
    gl.drawArrays(gl.TRIANGLES, 0, obj.verts.length/3);

    // --- Dibujar centroides (puntos rojos) ---
    gl.useProgram(programPoints);
    aPos = gl.getAttribLocation(programPoints, "aPosition");
    uMVP = gl.getUniformLocation(programPoints, "uMVP");
    gl.bindBuffer(gl.ARRAY_BUFFER, vboCentroides);
    gl.enableVertexAttribArray(aPos);
    gl.vertexAttribPointer(aPos, 3, gl.FLOAT, false, 0, 0);
    gl.uniformMatrix4fv(uMVP, false, mvp);
    gl.drawArrays(gl.POINTS, 0, obj.centroids.length/3);

    // --- Dibujar picos (l√≠neas desde centroides) ---
gl.useProgram(programLines);
let aLinePos = gl.getAttribLocation(programLines, "aPosition");
let uLineMVP = gl.getUniformLocation(programLines, "uMVP");
gl.bindBuffer(gl.ARRAY_BUFFER, vboLines);
gl.enableVertexAttribArray(aLinePos);
gl.vertexAttribPointer(aLinePos, 3, gl.FLOAT, false, 0, 0);
gl.uniformMatrix4fv(uLineMVP, false, mvp);
gl.drawArrays(gl.LINES, 0, obj.linePoints.length/3);

    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
}
main();
</script>
</body>
</html>
