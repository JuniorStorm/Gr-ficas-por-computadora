<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Letras animadas suaves y orden correcto</title>
<style>
  body { margin: 0; background: rgb(59, 59, 59); overflow: hidden; }
  canvas { width: 100vw; height: 100vh; display: block; }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script src="https://webglfundamentals.org/webgl/resources/webgl-utils.js"></script>
<script src="https://webglfundamentals.org/webgl/resources/m4.js"></script>
<script>
"use strict";

function parseOBJ(text) {
  const objPositions = [[0,0,0]], objTexcoords = [[0,0]], objNormals = [[0,0,0]];
  const objVertexData = [objPositions, objTexcoords, objNormals];
  const geometries = []; let geometry;
  function setGeometry() {
    if (!geometry) {
      geometry = { data: { position: [], texcoord: [], normal: [] } };
      geometries.push(geometry);
    }
  }
  function addVertex(v) {
    const ptn = v.split('/');
    ptn.forEach((str, i) => {
      if (!str) return;
      const objIndex = parseInt(str);
      const index = objIndex + (objIndex >= 0 ? 0 : objVertexData[i].length);
      geometry.data[Object.keys(geometry.data)[i]].push(...objVertexData[i][index]);
    });
  }
  const keywords = {
    v: p => objPositions.push(p.map(parseFloat)),
    vn: p => objNormals.push(p.map(parseFloat)),
    vt: p => objTexcoords.push(p.map(parseFloat)),
    f(p) {
      setGeometry();
      for (let t = 0; t < p.length - 2; ++t) {
        addVertex(p[0]); addVertex(p[t+1]); addVertex(p[t+2]);
      }
    },
    o() { geometry = undefined; }
  };
  const lines = text.split('\n');
  for (const line of lines) {
    const t = line.trim();
    if (!t || t.startsWith('#')) continue;
    const [key, ...parts] = t.split(/\s+/);
    const fn = keywords[key]; if (fn) fn(parts);
  }
  geometries.forEach(g => g.data = Object.fromEntries(Object.entries(g.data).filter(([_, a]) => a.length)));
  return { geometries };
}

function create1PixelTexture(gl, pixel) {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(pixel));
  return tex;
}

function createTexture(gl, url) {
  const texture = create1PixelTexture(gl, [128, 128, 128, 255]);
  const image = new Image();
  image.src = url;
  image.onload = () => {
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

    // Verificar si la imagen es potencia de 2
    function isPowerOf2(value) {
      return (value & (value - 1)) === 0;
    }

    if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
      gl.generateMipmap(gl.TEXTURE_2D);
    } else {
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    }
  };
  return texture;
}

async function main() {
  const canvas = document.querySelector("#canvas");
  const gl = canvas.getContext("webgl");
  if (!gl) return;

  const vs = `
    attribute vec4 a_position;
    attribute vec3 a_normal;
    attribute vec2 a_texcoord;
    uniform mat4 u_projection, u_view, u_world;
    varying vec3 v_normal;
    varying vec2 v_texcoord;
    void main() {
      gl_Position = u_projection * u_view * u_world * a_position;
      v_normal = mat3(u_world) * a_normal;
      v_texcoord = a_texcoord;
    }`;

  const fs = `
  precision highp float;
  varying vec3 v_normal;
  varying vec2 v_texcoord;
  uniform vec3 u_lightDirection;
  uniform sampler2D diffuseMap;
  uniform vec4 u_color;  // <-- NUEVO

  void main() {
    vec3 normal = normalize(v_normal);
    float light = dot(u_lightDirection, normal) * 0.5 + 0.5;

    // Si u_color tiene alpha 0 usamos textura, si no usamos color sólido
    vec4 baseColor = u_color.a > 0.0 
        ? u_color 
        : texture2D(diffuseMap, v_texcoord);

    gl_FragColor = vec4(baseColor.rgb * light, baseColor.a);
  }
`;

  const prog = webglUtils.createProgramInfo(gl, [vs, fs]);
  const objText = await fetch("Sin_nombre.obj").then(r => r.text());
  const obj = parseOBJ(objText);
  const parts = obj.geometries.map(g => ({
    bufferInfo: webglUtils.createBufferInfoFromArrays(gl, g.data),
    centerX: (g.data.position.reduce((a,v,i)=> i%3===0 ? a+v: a,0)) / (g.data.position.length/3)
  }));

  // Ordenar partes por su posición X media (izquierda a derecha)
  parts.sort((a,b)=>a.centerX-b.centerX);
  const names = ["S","A","H"];

  const texture = createTexture(gl, "fuego.jpg");
  const cameraPosition = [0, 3, 6]; // antes era [0, 0, 4]
  const target = [0, 0, 0];           // el punto al que mira
  const up = [0, 1, 0];
  const zNear = 0.1, zFar = 100;
  const degToRad = d => d * Math.PI / 180;
  const lerp = (a,b,t)=>a+(b-a)*t;
  const mixVec3 = (a,b,t)=>[lerp(a[0],b[0],t),lerp(a[1],b[1],t),lerp(a[2],b[2],t)];

  const originalPositions = {
    S: [-0.6808, 0, 1],
    A: [-0.0247, 0, 0],
    H: [0.8059, 0, -1],
  };

  const orderSets = [
    ["S","A","H"],
    ["H","S","A"],
    ["A","H","S"]
  ];

function render(time) {
  time *= 0.001;
  webglUtils.resizeCanvasToDisplaySize(gl.canvas);
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
  gl.enable(gl.DEPTH_TEST);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  const projection = m4.perspective(degToRad(60), aspect, zNear, zFar);
  const view = m4.inverse(m4.lookAt(cameraPosition, target, up));

  const lightDirection = m4.normalize([-1, 3, 5]);

  gl.useProgram(prog.program);
  webglUtils.setUniforms(prog, {
    u_lightDirection: lightDirection,
    u_view: view,
    u_projection: projection,
    diffuseMap: texture,
  });

  const rotation = m4.yRotation(time * 0.3);
  const moveDuration = 2.0, pauseDuration = 1.0, totalDuration = moveDuration + pauseDuration;
  const cycle = Math.floor(time / totalDuration);
  const phase = cycle % orderSets.length;
  const nextPhase = (phase + 1) % orderSets.length;
  const cycleTime = time % totalDuration;
  const t = Math.min(cycleTime / moveDuration, 1.0);
  const order = orderSets[phase];
  const nextOrder = orderSets[nextPhase];

  // === Plano morado (suelo) ===
  const planeSize = 6;
  const planeY = -1.0;

  if (!render.planeBuffer) {
    const planePositions = [
      -planeSize, planeY, -planeSize,
       planeSize, planeY, -planeSize,
      -planeSize, planeY,  planeSize,
      -planeSize, planeY,  planeSize,
       planeSize, planeY, -planeSize,
       planeSize, planeY,  planeSize,
    ];
    const planeNormals = new Array(18).fill(0).map((_, i) => (i % 3 === 1 ? 1 : 0));
    const planeTexcoords = new Array(12).fill(0);
    render.planeBuffer = webglUtils.createBufferInfoFromArrays(gl, {
      position: planePositions,
      normal: planeNormals,
      texcoord: planeTexcoords,
    });
  }

  webglUtils.setBuffersAndAttributes(gl, prog, render.planeBuffer);
  webglUtils.setUniforms(prog, {
    u_world: m4.identity(),
    u_color: [0.6, 0.2, 0.9, 1.0],
  });
  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // === Dibujar letras con sombras ===
  for (let i = 0; i < parts.length; ++i) {
    const { bufferInfo } = parts[i];
    const letter = names[i];
    const fromPos = originalPositions[order[i]];
    const toPos = originalPositions[nextOrder[i]];
    const smoothPos = mixVec3(fromPos, toPos, t);

    // Rebote vertical suave (como salto)
    const bounce = Math.sin(t * Math.PI) * 0.6; // altura del salto
    const height = smoothPos[1] + bounce;       // posición Y actual de la letra

    // === Sombra proyectada ===
    const shadowPlaneY = planeY + 0.001;
    const light = [-lightDirection[0], -lightDirection[1], -lightDirection[2]];

    // matriz de proyección plana (sombra)
    const m = [
      1, 0, -light[0] / light[1], 0,
      0, 0, -1, 0,
      0, 0, 1, 0,
      0, shadowPlaneY, 0, 1
    ];

    const u_world = m4.translate(m4.copy(rotation), smoothPos[0], height, smoothPos[2]);
    const shadowWorld = m4.multiply(u_world, m);

    // Escala dinámica de la sombra (más grande cuando está cerca del suelo)
    const shadowScale = 1.0 + (bounce / 0.6) * 0.5;

    // Aplica primero la escala y luego la proyección de sombra
    const shadowScaled = m4.multiply(
      m4.scale(m4.copy(u_world), shadowScale, 1, shadowScale),
      m
    );
    // --- Dibujar sombra ---
    webglUtils.setBuffersAndAttributes(gl, prog, bufferInfo);
    webglUtils.setUniforms(prog, {
      u_world: shadowScaled,
      u_color: [0.0, 0.0, 0.45, 0.45], // sombra 
    });
    webglUtils.drawBufferInfo(gl, bufferInfo);

    // --- Dibujar letra real ---
    webglUtils.setUniforms(prog, {
      u_world,
      u_color: [0, 0, 0, 0], // usa textura
    });
    webglUtils.drawBufferInfo(gl, bufferInfo);
  }

  requestAnimationFrame(render);
}
  requestAnimationFrame(render);
}
main();
</script>
</body>
</html>
