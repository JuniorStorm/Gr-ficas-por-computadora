<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Árbol Fractal Animado en WebGL</title>
 <style>
  body {
    margin: 0;
    display: flex;              
    justify-content: center;    
    align-items: flex-start;       
    height: 100vh;              
    background: white;          
  }

  canvas {
    width: 600px;              
    height: 400px;              
    display: block;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<script>
const canvas = document.getElementById("canvas");
const gl = canvas.getContext("webgl");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Shaders
const vsSource = `
  attribute vec2 a_position;
  uniform vec2 u_resolution;
  void main() {
    vec2 zeroToOne = a_position / u_resolution;
    vec2 zeroToTwo = zeroToOne * 2.0;
    vec2 clipSpace = zeroToTwo - 1.0;
    gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }
`;

const fsSource = `
  void main() {
    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // negro
  }
`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}
function createProgram(gl, vsSource, fsSource) {
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  return program;
}

const program = createProgram(gl, vsSource, fsSource);
gl.useProgram(program);

const positionLocation = gl.getAttribLocation(program, "a_position");
const resolutionLocation = gl.getUniformLocation(program, "u_resolution");

// Buffer de posiciones
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.enableVertexAttribArray(positionLocation);
gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

let lines = [];
let branches = []; // ramas pendientes para animación

// Genera recursivamente pero guarda ramas en cola
function generateBranches(x, y, length, angle, depth) {
  if (depth === 0) return;
  const x2 = x + length * Math.cos(angle);
  const y2 = y + length * Math.sin(angle);

  // Guardamos esta rama en la lista
  branches.push([x, y, x2, y2, length, angle, depth]);

  // Generamos hijos (se añadirán después en animación)
  setTimeout(() => {
    generateBranches(x2, y2, length * 0.7, angle - Math.PI / 6, depth - 1);
    generateBranches(x2, y2, length * 0.7, angle + Math.PI / 6, depth - 1);
  }, 500); // retraso de 200ms por nivel
}

// Dibuja todas las líneas acumuladas
function render() {
  gl.uniform2f(resolutionLocation, canvas.width, canvas.height);
  gl.clearColor(1, 1, 1, 1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(lines), gl.STATIC_DRAW);
  gl.drawArrays(gl.LINES, 0, lines.length / 2);
}

// Función de animación: va tomando ramas de la cola
function animate() {
  if (branches.length > 0) {
    const [x, y, x2, y2, length, angle, depth] = branches.shift();
    lines.push(x, y, x2, y2);
    render();
  }
  requestAnimationFrame(animate);
}

// Inicia árbol
const startX = canvas.width / 2; 
const startY = canvas.height *0.9;

generateBranches(startX, startY, 200, -Math.PI / 2, 8);

animate();

</script>
</body>
</html>
