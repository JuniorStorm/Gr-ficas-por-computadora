<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Ordenamiento WebGL2 con Colores</title>
<style>
body {
  margin: 0;
  background: #071227;
  color: #e6eef6;
  font-family: Inter, Arial, sans-serif;
  display: flex;
  flex-direction: column;
  align-items: center;
}
canvas {
  width: 100vw;
  height: 420px;
  background: linear-gradient(180deg, #031022, #071827);
  border-radius: 10px;
  box-shadow: 0 8px 30px rgba(0,0,0,.6);
}
.panel {
  width: 100%;
  max-width: 950px;
  background: #0f1b26;
  padding: 16px;
  border-radius: 0 0 10px 10px;
  box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 10px;
}
.panel select, .panel button {
  padding: 8px 12px;
  border-radius: 8px;
  border: none;
  background: #144257;
  color: #e6eef6;
  cursor: pointer;
}
.panel button.secondary { background: #18323a; }
.status {
  flex-basis: 100%;
  text-align: center;
  color: #9fb7c7;
  font-size: 13px;
}
</style>
</head>
<body>
<canvas id="gl"></canvas>
<div class="panel">
  <label>Forma:</label>
  <select id="shape"><option value="rect">Rectángulo</option><option value="star">Estrella</option></select>
  <label>Instancias:</label>
  <select id="count"><option>5</option><option>6</option><option>7</option><option>8</option></select>
  <button id="shuffle">Aleatorizar</button>
  <button id="reset" class="secondary">Reset</button>
  <button id="bubble">Bubble Sort</button>
  <button id="insert">Insertion Sort</button>
  <button id="merge" class="secondary">Merge Sort</button>
  <button id="quick">Quick Sort</button>
  <label>Velocidad:</label>
  <select id="speed"><option value="900">Lento</option><option value="450" selected>Normal</option><option value="160">Rápido</option></select>
  <div class="status" id="status">Estado: listo</div>
</div>

<script>
// --- Función auxiliar HSV->RGB ---
function hsvToRgb(h, s, v) {
  let f = (n, k = (n + h * 6) % 6) =>
    v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
  return [f(5), f(3), f(1)];
}

// --- WebGL setup ---
const canvas = document.getElementById("gl");
const gl = canvas.getContext("webgl2");
if(!gl){alert("Tu navegador no soporta WebGL2"); throw "no webgl2";}

// --- Shaders ---
const vs = `#version 300 es
in vec2 a_pos;
in vec2 a_offset;
in float a_size;
in vec3 a_color;
out vec3 v_color;
out vec2 v_local;
void main(){
  // ancho fijo, altura según a_size
  vec2 scaled = vec2(a_pos.x * 0.05, a_pos.y * a_size);
  vec2 pos = a_offset + scaled;
  gl_Position = vec4(pos,0,1);
  v_color = a_color;
  v_local = a_pos;
}`;

const fs = `#version 300 es
precision highp float;
uniform int u_shape;
in vec3 v_color;
in vec2 v_local;
out vec4 o_color;

float sdStar(vec2 p){
  vec2 q = p * 0.6;
  float a = atan(q.y,q.x);
  float r = length(q);
  float k = cos(5.0*a)*0.45 + 0.5;
  return r - k*0.5;
}

void main(){
  if(u_shape==0){
    if(abs(v_local.x)>1.0 || abs(v_local.y)>1.0) discard;
    o_color = vec4(v_color, 1.0);
  } else {
    float d = sdStar(v_local);
    if(d>0.0) discard;
    o_color = vec4(v_color, 1.0);
  }
}`;

function compile(type,src){
  const s=gl.createShader(type);
  gl.shaderSource(s,src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s,gl.COMPILE_STATUS))
    console.error(gl.getShaderInfoLog(s));
  return s;
}
const prog = gl.createProgram();
gl.attachShader(prog,compile(gl.VERTEX_SHADER,vs));
gl.attachShader(prog,compile(gl.FRAGMENT_SHADER,fs));
gl.linkProgram(prog);
gl.useProgram(prog);

// --- atributos y uniformes ---
const a_pos = gl.getAttribLocation(prog,"a_pos");
const a_offset = gl.getAttribLocation(prog,"a_offset");
const a_size = gl.getAttribLocation(prog,"a_size");
const a_color = gl.getAttribLocation(prog,"a_color");
const u_shape = gl.getUniformLocation(prog,"u_shape");

// --- VAO ---
const vao = gl.createVertexArray();
gl.bindVertexArray(vao);

// Quad base
const verts = new Float32Array([
  -1,-1, 1,-1, -1,1,
  -1,1, 1,-1, 1,1
]);
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
gl.bufferData(gl.ARRAY_BUFFER,verts,gl.STATIC_DRAW);
gl.enableVertexAttribArray(a_pos);
gl.vertexAttribPointer(a_pos,2,gl.FLOAT,false,0,0);

// Buffers de instancias
const bufOff = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bufOff);
gl.enableVertexAttribArray(a_offset);
gl.vertexAttribPointer(a_offset,2,gl.FLOAT,false,0,0);
gl.vertexAttribDivisor(a_offset,1);

const bufSize = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bufSize);
gl.enableVertexAttribArray(a_size);
gl.vertexAttribPointer(a_size,1,gl.FLOAT,false,0,0);
gl.vertexAttribDivisor(a_size,1);

const bufColor = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER,bufColor);
gl.enableVertexAttribArray(a_color);
gl.vertexAttribPointer(a_color,3,gl.FLOAT,false,0,0);
gl.vertexAttribDivisor(a_color,1);

// --- Modelo lógico ---
let instances = [];
let instanceCount = 5;
const margin = 0.06;

function makeInstances(n){
  instanceCount = n;
  instances = [];
  for(let i=0;i<n;i++){
    const s = 0.1 + i*0.03;
    const hue = Math.random();
    const color = hsvToRgb(hue,0.7,0.9);
    instances.push({size:s,color});
  }
  shuffle(instances);
  layoutPositions();
}
function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}}
function layoutPositions(){
  const left=-1+margin, right=1-margin;
  const span=right-left, n=instances.length;
  for(let i=0;i<n;i++){
    const slot=(i+0.5)/n;
    instances[i].x=left+slot*span;
    instances[i].y=0.0;
  }
}
function uploadBuffers(){
  const n=instances.length;
  const offs=new Float32Array(n*2);
  const sizes=new Float32Array(n);
  const cols=new Float32Array(n*3);
  for(let i=0;i<n;i++){
    offs[i*2]=instances[i].x;
    offs[i*2+1]=instances[i].y;
    sizes[i]=instances[i].size;
    const c=instances[i].color;
    cols[i*3]=c[0]; cols[i*3+1]=c[1]; cols[i*3+2]=c[2];
  }
  gl.bindBuffer(gl.ARRAY_BUFFER,bufOff);
  gl.bufferData(gl.ARRAY_BUFFER,offs,gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER,bufSize);
  gl.bufferData(gl.ARRAY_BUFFER,sizes,gl.DYNAMIC_DRAW);
  gl.bindBuffer(gl.ARRAY_BUFFER,bufColor);
  gl.bufferData(gl.ARRAY_BUFFER,cols,gl.DYNAMIC_DRAW);
}

function draw(){
  gl.viewport(0,0,gl.canvas.width,gl.canvas.height);
  gl.clearColor(0.03,0.08,0.15,1);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.useProgram(prog);
  gl.bindVertexArray(vao);
  gl.uniform1i(u_shape, document.getElementById("shape").value==="rect"?0:1);
  gl.drawArraysInstanced(gl.TRIANGLES,0,6,instances.length);
}

// --- UI ---
const elCount=document.getElementById("count");
const elShuffle=document.getElementById("shuffle");
const elReset=document.getElementById("reset");
const elStatus=document.getElementById("status");

function setCanvasSize(){
  const ratio=window.devicePixelRatio||1;
  const width=window.innerWidth;
  canvas.width=Math.floor(width*ratio);
  canvas.height=Math.floor(420*ratio);
  canvas.style.width=width+'px';
  canvas.style.height='420px';
  layoutPositions();
  uploadBuffers();
  draw();
}
window.addEventListener('resize',setCanvasSize);
setCanvasSize();

function init(n){
  makeInstances(n);
  uploadBuffers();
  draw();
}
init(parseInt(elCount.value));

elCount.addEventListener('change',()=>{init(parseInt(elCount.value));});
elShuffle.addEventListener('click',()=>{shuffle(instances);layoutPositions();uploadBuffers();draw();elStatus.textContent='Estado: aleatorizado';});
elReset.addEventListener('click',()=>{init(parseInt(elCount.value));elStatus.textContent='Estado: reset';});

function loop(){uploadBuffers();draw();requestAnimationFrame(loop);}
requestAnimationFrame(loop);
</script>
</body>
</html>
